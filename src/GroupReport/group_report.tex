\documentclass[sigconf]{acmart}
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column

\usepackage{graphicx}
\usepackage{comment}
\usepackage{float}
\usepackage{kotex}
\usepackage{listings} 
\lstset{language=C++}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}


\copyrightyear{2019}
\acmYear{2019}
\acmConference{CS454 AI Based Software Engineering}{2019 Fall}{KAIST}
\setcopyright{none}
\acmDOI{}

\begin{document}

\title{MiniCS: Critical Section Minimisation in Concurrent Programming}
\author{Hyunsu Kim}
\affiliation{
  \institution{KAIST}
  \city{Daejeon, Rep. of Korea}
}
\email{hyunsu.kim00@kaist.ac.kr}

\author{Jaemin Yu}
\affiliation{
  \institution{KAIST}
  \city{Daejeon, Rep. of Korea}
}
\email{platinant@kaist.ac.kr}

\author{Doam Lee}
\affiliation{
  \institution{KAIST}
  \city{Daejeon, Rep. of Korea}
}
\email{ehdkacjswo@kaist.ac.kr}

\author{Jaemin Choi}
\affiliation{
  \institution{KAIST}
  \city{Daejeon, Rep. of Korea}
}
\email{jmchoi98@kaist.ac.kr}

\author{Heeju Wi}
\affiliation{
  \institution{KAIST}
  \city{Daejeon, Rep. of Korea}
}
\email{bb0711@kaist.ac.kr}

\begin{abstract}
Modern machines consume massive amount of data as well as drastic amount of computations, as the era of artificial intelligence. In the hardware manufacturing industry, developing SoC optimized to such computations is an already on-going process. Multi-core with machines are prevalent nowadays. Still, thanks to the end of Moore's law and Dennard's scaling, software implementation that synchronizes multiple threads is unavoidable in order to achieve reasonably scalable computing. However, it is often a fear to write multi-threaded code due to its non-deterministic behavior. In order to tame the parallelism with scalability, using synchronization primitives such as lock and semaphore is mandatory to prevent race conditions. While which API to use is rather trivial, it is usually known that setting critical sections (when to acquire a lock, then when to release the lock) is not trivial at all. In this work, we tackle such intractability by applying combination of heuristics for search and static analysis for rigorous evaluation and correctness.
\end{abstract}

\maketitle

\section{Introduction}
Multi-threaded codes often come up with the problem called data race. It means multiple threads access the same memory location concurrently and at least one of them is writing. It may cause computation give wrong output depending on their execution order. It can be resolved by using exclusive locks to control accesses to that memory. But abusing lock will interrupt other threads' execution and it will lead to longer execution time.
So it's important to protect shared memory location by using locks and also minimizing the interval(execution time) between lock and unlock. But it's hard to be achieved by hand, and some of races can be only detected on runtime.
Our project MiniCS is solution for this problem. It produces population of candidate codes with locks and perform GA to get best code that's without data race and has minimum "lock interval" (Lock interval means "execution time between lock including lock and unlock themselves" on this paper).

\input{sections/background.tex}

\subsection{Critical section}

\subsection{Genetic algorithm}

\section{Experiment design}

\input{sections/environment.tex}

\subsection{Gene representation}

\input{sections/population_generation.tex}

\subsection{Mutation}

\subsection{Crossover}

\subsection{Static analyzer}
What does it mean?

\subsection{Fitness evaluation}
Since our goal is to build code "without data race" and has "minimum lock interval", we have two objective for fitness evaluation. 

\subsubsection{Data race free}
First objective is number of "racing sets". The term "racing set" means the set of two lines that have data race. Since we need data race free code, we need to minimize the number of racing sets to 0. And this number can be obtained by data race detector, ThreadSanitizer. It's part of Clang that can detect data race for given code. The detection report will be offered like the sample below:

\begin{lstlisting}[frame=tb, xleftmargin=2em, framexleftmargin=1.5em, numbers=left]
WARNING: ThreadSanitizer: data race
  Write of size 4 at 0x7fe3c3075190:
    #0 bar1() simple_stack2.cc:16
    #1 Thread1(void*) simple_stack2.cc:34

  Previous read of size 4 at 0x7fe3c3075190:
    #0 bar2() simple_stack2.cc:29
    #1 main simple_stack2.cc:41
\end{lstlisting}

This report gives us four racing sets $(16, 29)$, $(16, 41)$, $(34, 29)$, $(34, 41)$ that each $(a, b)$ means $a$-th line and $b$-th line have data race. Since the detection result of ThreadSanitizer depends on execution order of threads, we execute ThreadSanitizer for every possible execution orders (for $n$ threads, execute for $n!$ times) and count the number of distinct racing sets.
 
\subsubsection{Lock interval}
Second objective is number of machine instructions between locks(including themselves). Lock interval is 

\section{Evaluation}


\section{Conclusion}
As a result,
Slowdown of the program is occured by two reasons
\begin{enumerate}
    \item ThreadSanitizer should be executed for every possible execution order of threads.
    \item GDB runs the program step by step between locks.
\end{enumerate}
To resolve this problem, 
Possible improvements (e.g. Coevolution with Thread schedule with Qemu emulator)


\end{document}
